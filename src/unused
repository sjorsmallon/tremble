
using namespace std::literals;
struct vec3f_t
{
    union {
        struct {
            float x,y,z;
        };
        struct {
            float a,b,c;
        };
        struct {
        float u,v,w;
        };
        float arr[3];
      };
};

struct Position
{
    float x;
    float y;
    float z;
};

// where are they looking?
struct Orientation
{
    vec3f_t forward;
    vec3f_t right;
};

// where are they heading?
struct Velocity
{
    vec3f_t v;
};

static_assert(sizeof(Position) == sizeof(vec3f_t));

// to be synced over the network. this could just be a bag of entities
// but I want to keep players separate for now so I can think about it.
struct GameState
{
    std::vector<Entity> players;
    std::vector<Entity> everything_else;
};

static GameState g_game_state{};

// already this is not good because of the registry thing. we should pass registry in here.
static Entity create_player()
{   
    auto& registry = get_registry();
    auto entity = registry.CreateEntity();
    entity.AddComponent<Position>(10.0f, 10.0f, 0.0f);
    entity.AddComponent<Orientation>(vec3f_t{1.0f, 0.0f, 0.0f},vec3f_t{0.0f, 0.0f, 1.0f});
    entity.AddComponent<Velocity>();

    g_game_state.players.push_back(entity);
    return entity;
}

static bool connect_to_server()
{
    return false;
}





    auto default_triangle_vertices = create_default_triangle();
    auto default_triangle_buffer = create_interleaved_xnc_buffer(default_triangle_vertices);

    const char* base_vertex_shader_src = R"(
               #version 330 core
        layout(location = 0) in vec3 aPos;     // Vertex position
        layout(location = 1) in vec3 aNormal;  // Vertex normal (not used in this simple shader)
        layout(location = 2) in vec4 aColor;    // Vertex color

        out vec4 FragColor; // Output color to fragment shader

        void main() {
            gl_Position = vec4(aPos, 1.0); // Transform to clip space
            FragColor = aColor;             // Pass color to fragment shader
        })";

    const char* base_fragment_shader_src = R"(
        #version 330 core
        in vec4 FragColor; // Input color from vertex shader
        out vec4 finalColor; // Final color output

        void main() {
            finalColor = FragColor; // Set the output color
    })";

    auto base_shader_program = create_shader_program(
        base_vertex_shader_src,
        base_fragment_shader_src
        );


// random glsl snippets.
randomize_color_for_each_face
{
    
  float random_from_seed(int seed)
   {
        // A simple hash function using bitwise operations and multiplication
        seed = (seed ^ 61) ^ (seed >> 16);   
        seed = seed + (seed << 3);           
        seed = seed ^ (seed >> 4);           
        seed = seed * 0x27d4eb2d;            
        seed = seed ^ (seed >> 15);          

        return float(seed & 0xFFFFFF) / 0xFFFFFF; // Normalize to [0, 1]
    }

    // Function to get a random color based on an integer seed
    vec3 random_color_from_seed(int seed) {
        float r = random_from_seed(seed);     // Random red component
        float g = random_from_seed(seed + 1); // Random green component
        float b = random_from_seed(seed + 2); // Random blue component

        return vec3(r, g, b);                  // Return the RGB color as a vec3
    }

    // awful trick to perform integer division to get vertices to agree on a color.
    int face_id = gl_VertexID / 3;
    color_frag_in = vec4(random_color_from_seed(face_id), 1.0f);
}
